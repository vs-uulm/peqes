use std::mem::size_of;
use uuid::Uuid;

#[cfg(target_env = "sgx")]
use std::io::{Read, Write};

#[cfg(target_env = "sgx")]
use sgx_crypto::random::RandomState;

#[cfg(target_env = "sgx")]
use sgx_crypto::key_exchange::OneWayAuthenticatedDHKE;

#[cfg(target_env = "sgx")]
use sgx_crypto::signature::VerificationKey;

#[cfg(target_env = "sgx")]
use sgx_crypto::digest::sha256;

#[cfg(target_env = "sgx")]
use sgx_isa::{Targetinfo, Report, Keyname, Keyrequest};

#[cfg(target_env = "sgx")]
use sgx_crypto::cmac::Cmac;

pub type Quote = [u8; 1116]; // 436 + quote.signature_len for version 2

/// Verifies a report created by locally_attest (or any other report generated by an enclave).
/// Returns true if the report is correctly formed and has been generated on the same machine/CPU
/// as the current enclave.
#[cfg(target_env = "sgx")]
pub fn verify_local_attest(report: &[u8]) -> Result<(), LocalAttestationError>{
    if report.len() != Report::UNPADDED_SIZE {
        return Err(LocalAttestationError::IncorrectReportLength);
    }
    // Can unwrap since the length is verified
    let report = Report::try_copy_from(report).unwrap();
    verify_report(&report)
}

/// Verifies the given report locally, a.k.a. returns true if the Report was created in an enclave
/// on the same CPU.
#[cfg(target_env = "sgx")]
pub fn verify_report(report: &Report) -> Result<(), LocalAttestationError>{
    // Derive the report key.
    let request = Keyrequest {
        keyname: Keyname::Report as _,
        keyid: report.keyid.clone(),
        ..Default::default()
    };
    // Maybe result false instead of panicking, but the specs
    // ( https://software.intel.com/en-us/articles/intel-sdm Volume 3C, Chapter 40-4 )
    // state that EGETKEY should have a problem with this parameters, so if it doesn't work
    // there might be a deeper issue making a panic appropriate.
    let key = request.egetkey().expect("Can't derive report key");

    // Extract the data that is signed.
    let report_data: &[u8] = report.as_ref();
    let mut mac_data = &report_data[0..Report::UNPADDED_SIZE-48];

    // Compute and verify the mac on the data.
    let mac = Cmac::new(&key);
    mac.verify(&mut mac_data, &report.mac)
        .map_err(|_| LocalAttestationError::IntegrityError)
}

pub type EnclaveRaResult<T> = Result<T, EnclaveRaError>;

#[derive(Debug)]
pub enum EnclaveRaError {
    KeyExchange(sgx_crypto::key_exchange::KeError),
    Signature(sgx_crypto::signature::SigError),
    Io(std::io::Error),
#[cfg(target_env = "sgx")]
    ReportDataLongerThan64Bytes,
#[cfg(target_env = "sgx")]
    LocalAttestation(LocalAttestationError),
#[cfg(target_env = "sgx")]
    AttestationFailed,
    Base64(base64::DecodeError),
    Unit(())
}

impl std::convert::From<sgx_crypto::key_exchange::KeError> for EnclaveRaError {
    fn from(e: sgx_crypto::key_exchange::KeError) -> Self { Self::KeyExchange(e) }
}

impl std::convert::From<sgx_crypto::signature::SigError> for EnclaveRaError {
    fn from(e: sgx_crypto::signature::SigError) -> Self { Self::Signature(e) }
}

impl std::convert::From<std::io::Error> for EnclaveRaError {
    fn from(e: std::io::Error) -> Self { Self::Io(e) }
}

impl std::convert::From<base64::DecodeError> for EnclaveRaError {
    fn from(e: base64::DecodeError) -> Self { Self::Base64(e) }
}

impl std::convert::From<()> for EnclaveRaError {
    fn from(e: ()) -> Self { Self::Unit(e) }
}

#[derive(Debug)]
pub enum LocalAttestationError {
#[cfg(target_env = "sgx")]
    IncorrectReportLength,
#[cfg(target_env = "sgx")]
    IntegrityError,
}

#[cfg(target_env = "sgx")]
pub struct RaContext {
    client: std::net::TcpStream,
    id: String,
    key_exchange: Option<OneWayAuthenticatedDHKE>,
    sp_vkey: VerificationKey,
    gid: [u8; 4],
    target_info: [u8; 512],
    kdk: Option<[u8; 16]>
}

#[cfg(target_env = "sgx")]
impl RaContext {
    pub fn init(sp_vkey_pem: &str) -> EnclaveRaResult<Self>  {
        let mut gid = [0 as u8; 4];
        let mut target_info = [0 as u8; 512];

        let mut client = std::net::TcpStream::connect("attestation")?;
        client.read_exact(&mut gid)?;
        client.read_exact(&mut target_info)?;

        let rng = RandomState::new();
        let key_exchange = OneWayAuthenticatedDHKE::generate_keypair(&rng)?;

        Ok(Self {
            id: Uuid::new_v4().to_hyphenated().to_string(),
            sp_vkey: VerificationKey::new_from_pem(sp_vkey_pem)?,
            key_exchange: Some(key_exchange),
            gid,
            target_info,
            client,
            kdk: None
        })
    }

    pub fn get_id(&self) -> String {
        self.id.to_string()
    }


    pub fn get_msg_01(&self) -> String {
        let g_a = self.key_exchange.as_ref().unwrap().get_public_key().to_owned();

        json!({
            "id": self.id,
            "ExGID": 0,
            "Ga": base64::encode(&g_a[..]),
            "GID": base64::encode(&self.gid)
        }).to_string()
    }

    // Return (signing key, master key)
    pub fn process_msg_2(&mut self, msg2: &serde_json::Value) -> Result<String, EnclaveRaError> {
        let g_a = self.key_exchange.as_ref().unwrap().get_public_key().to_owned();

        let gb = base64::decode(msg2.get("Gb").ok_or(())?.as_str().ok_or(())?)?;
        let spid = base64::decode(msg2.get("SPID").ok_or(())?.as_str().ok_or(())?)?;
        let signature = base64::decode(msg2.get("SigSP").ok_or(())?.as_str().ok_or(())?)?;
        let sigrl = base64::decode(msg2.get("SigRL").ok_or(())?.as_str().ok_or(())?)?;
        let quote_type: u16 = msg2.get("TYPE").ok_or(())?.as_u64().ok_or(())? as u16;

        let mut aad = Vec::new();
        aad.extend_from_slice(&spid[..]);
        aad.extend_from_slice(&quote_type.to_le_bytes()[..]);

        let mut g_b = [0 as u8; 65];
        g_b.copy_from_slice(&gb);

        // Verify and derive KDK
        let kdk = self.key_exchange.take().unwrap().verify_and_derive(&g_b, &signature, Some(&aad[..]), &self.sp_vkey)?;
        self.kdk = Some(kdk);

        let ps_sec_prop: Vec<u8> = Vec::new();

        // Obtain SHA-256(g_a || g_b || ps_sec_prop) 
        let mut verification_msg = Vec::new();
        verification_msg.extend_from_slice(&g_a);
        verification_msg.extend_from_slice(&g_b);
        verification_msg.extend_from_slice(&ps_sec_prop);
        let verification_digest = sha256(&verification_msg[..]);

        // Obtain and verify quote 
        let quote = self.get_quote(&verification_digest[..], &spid, &sigrl)?;

        Ok(json!({
            "Ga": base64::encode(&g_a[..]),
            "PS_SEC_PROP": base64::encode(&ps_sec_prop[..]),
            "QUOTE": base64::encode(&quote[..])
        }).to_string())
    }

    fn get_quote(&mut self, report_data: &[u8], spid: &[u8], sigrl: &[u8]) -> EnclaveRaResult<Quote> {
        if report_data.len() > 64 || spid.len() > 16 {
            return Err(EnclaveRaError::ReportDataLongerThan64Bytes);
        }

        // Obtain QE's target info to build a report for local attestation. 
        // Then, send the report back to client.
        let mut _report_data = [0u8; 64];
        (&mut _report_data[..(report_data.len())]).copy_from_slice(report_data);

        let target_info = Targetinfo::try_copy_from(&self.target_info).unwrap();
        let report = Report::for_target(&target_info, &_report_data);

        self.client.write_all(&sigrl.len().to_be_bytes())?;
        self.client.write_all(&sigrl)?;
        self.client.write_all(&spid)?;
        self.client.write_all(report.as_ref())?;

        // Obtain quote and QE report from client 
        let mut quote = [0u8; size_of::<Quote>()];
        self.client.read_exact(&mut quote[..]).unwrap();

        let mut qe_report = vec![0u8; 432];
        self.client.read_exact(&mut qe_report[..]).unwrap();

        // Verify that the report is generated by QE
        verify_local_attest(&qe_report[..]).map_err(|e| EnclaveRaError::LocalAttestation(e))?;

        Ok(quote)
    }

    pub fn complete_attestation(mut self) -> EnclaveRaResult<[u8; 16]> {
        self.kdk.take().ok_or(EnclaveRaError::AttestationFailed)
    }
}

#[cfg(not(target_env = "sgx"))]
pub struct RaContext { }

#[cfg(not(target_env = "sgx"))]
impl RaContext {
    pub fn init(_: &str) -> EnclaveRaResult<Self>  {
        Ok(Self { })
    }

    pub fn get_id(&self) -> String {
        Uuid::nil().to_hyphenated().to_string()
    }


    pub fn get_msg_01(&self) -> String {
        json!({
            "id": Uuid::nil().to_hyphenated().to_string(),
            "ExGID": 0,
            "Ga": base64::encode(&[0u8; 65][..]),
            "GID": base64::encode(&[0u8; 4][..])
        }).to_string()
    }

    // Return (signing key, master key)
    pub fn process_msg_2(&self, _: &serde_json::Value) -> Result<String, EnclaveRaError> {
        Ok(json!({
            "Ga": base64::encode(&[0u8; 65][..]),
            "PS_SEC_PROP": base64::encode(&[0u8; 0][..]),
            "QUOTE": base64::encode(&[0u8; size_of::<Quote>()][..])
        }).to_string())
    }

    pub fn complete_attestation(self) -> EnclaveRaResult<[u8; 16]> {
        Ok([0u8; 16])
    }
}
